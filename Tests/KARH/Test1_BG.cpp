#include <iostream>
#include <cstdlib>
#include <vector>
#include <ctime>
#include <algorithm>
#include <string>
unsigned counter = 0;
struct Option
{
	Option(const std::string&, const double);
	double val = 0;
	std::string text;
};
Option::Option(const std::string& txt, const double val) : text(txt), val(val)
{
}
class Question
{
public:
	Question(const std::string&);
	void AddOption(const std::string&, const double);
	void AskQuestion();
	int AnswerQuestion();
private:
	std::string m_Question;
	std::vector<Option>m_Answers;
	double m_Score = 0;
};
void Question::AddOption(const std::string& rhs, const double val)
{
	Option opt(rhs, val);
	m_Answers.push_back(opt);
}
Question::Question(const::std::string& task) : m_Question(task)
{
}
int Randomize(const int i)
{
	return std::rand() % i;
}
void Question::AskQuestion()
{
	std::cout << m_Question << "\n\n";
	std::srand(unsigned(std::time(0)));
	for (unsigned i = 0; i < m_Answers.size(); ++i)
		std::swap(m_Answers[Randomize(m_Answers.size())], m_Answers[Randomize(m_Answers.size())]);
	for (unsigned i = 0; i < m_Answers.size(); ++i)
	{
		char ind = i + 65;
		std::cout << ind << ' ' << m_Answers[i].text << '\n';
	}
}

int Question::AnswerQuestion()
{
	char tmp = 'v';
	unsigned tmpToInt;
	std::cin >> tmp;
	tmpToInt = tmp;
	do
	{
		if (tmpToInt < 97)
			tmpToInt -= 65;
		else
			tmpToInt -= 97;
		m_Score += m_Answers[tmpToInt].val;
		std::cin >> tmp;
		tmpToInt = tmp;
	} while (tmp != 's' && tmp != 'S');
	std::cout << "Резултат: " << m_Score << "\nВерен отговор(и): ";
	for (unsigned i = 0; i < m_Answers.size(); ++i)
		if (m_Answers[i].val > 0)
			std::cout << char(i + 65) << ' ';
	std::cout << "\nВъведи някой символ...\n";
	if (m_Score > 0)
		counter++;
	return m_Score;
}
int main()
{
	setlocale(LC_ALL, "Bulgarian");

	std::cout << "Тест 1 по КАРХ.\nИзготвен от Марто, Даката, Икбал и М.\nПреведен от shlokavica на български от Ицо.\n";
	std::cout << "За да отговорите на някой въпрос, въведете буквата (буквите) и когато сте готови въведете 's'.\n";
	std::cout << "Съобразете се как работи std::cin.\nАко желаете симулация без повторни опити, натиснете r.\nАко желаете въпросите, които объркате да се запазват, натиснете произволен бутон.\n";
	char useless;
	std::cin >> useless;
	bool flag = (useless == 'r' ? 1 : 0);
	system("CLS");
	std::vector<Question> exam;
	std::srand(unsigned(std::time(0)));

	//cache memory
	Question d0("Кой от трите метода на разполагане на блокове от оперативната памет се имплементира най-лесно (изберете едно)?");
	d0.AddOption("Директно съпоставяне", 1);
	d0.AddOption("Пълна асоциативност", -1);
	d0.AddOption("Множествена асоциативност", -1);
	exam.push_back(d0);

	Question d1("Отбележете невярното твърдение (изберете едно):");
	d1.AddOption("Главната (DRAM) памет е по-бавна от SRAM паметта", -1);
	d1.AddOption("DRAM консумира повече енергия от SRAM", -1);//tuka rusalchoto go smeni,moje i da e greshno
	d1.AddOption("Кеш-паметта е малка, бърза и SRAM базирана", -1);
	d1.AddOption("SRAM е по-евтина DRAM", 1);
	exam.push_back(d1);

	Question d2("Каква е корелацията капацитет и бързодействие при компютърните памети (изберете едно)?");
	d2.AddOption("Пропорционална", -1);
	d2.AddOption("Обратнопропорционална", 1);//verniqt
	d2.AddOption("Няма корелация", -1);
	exam.push_back(d2);

	Question d3("Какъв е формата на линията при кеш-паметта с множествена асоциативност (изберете едно)?");
	d3.AddOption("таг, дума", -1);
	d3.AddOption("таг, линия, дума", -1);
	d3.AddOption("таг, множество, дума", 1);//verniqt
	exam.push_back(d3);

	Question d4("Кой вид памети са по-бързи от кеш-паметите (изберете едно)?");
	d4.AddOption("Регистрите", 1);//tova e verniqt otgovor
	d4.AddOption("Флаш паметите", -1);
	d4.AddOption("Главната памет", -1);
	exam.push_back(d4);

	Question d5("Методът, при който обновяване на главната памет настъпва асинхронно след премахване на дума от кеша се нарича (изберете едно)?");
	d5.AddOption("Защитен запис", -1);
	d5.AddOption("Write-back", 1);//verniqt
	d5.AddOption("Cache-write", -1);
	d5.AddOption("Write-through", -1);
	exam.push_back(d5);

	Question q31("Методът, при който обновяване на главната памет настъпва синхронно след премахване на дума от кеша се нарича (изберете едно)?");
	q31.AddOption("Защитен запис", -1);
	q31.AddOption("Write-back", -1);//verniqt
	q31.AddOption("Cache-write", -1);
	q31.AddOption("Write-trough", 1);
	exam.push_back(q31);

	Question d6("Какъв е форматът на линията при кеш-памет с пълна асоциативност?");
	d6.AddOption("таг, линия, дума", -1);
	d6.AddOption("таг, дума", 1);
	d6.AddOption("таг, множество, дума", -1);
	exam.push_back(d6);

	Question d7("Дадена е машина с побайтово адресируема основна памет с размер 2^16 байта и размер на блока 8 байта. Кеш-паметта е с \nдиректна организация и се състои от 32 линии. Какъв е максималният брой байтове, които могат да бъдат разположени в кеш-паметта (изберете едно)?");
	d7.AddOption("256B", 1);//verniqt
	d7.AddOption("1024B", -1);
	d7.AddOption("512B", -1);
	d7.AddOption("128B", -1);
	d7.AddOption("64B", -1);
	exam.push_back(d7);

	Question d8("LFU е алгоритъм за:");
	d8.AddOption("заместване на най-често използваната страница от кеш-паметта", -1);
	d8.AddOption("заместване на най-неизползваната страница в кеш-паметта", 1);//veren
	d8.AddOption("заместване на някои от използваните страници в кеш-паметта", -1);
	d8.AddOption("периодично изчистване признаците за обръщение към най-рядко използваните страници в кеш-паметта", -1);
	exam.push_back(d8);

	Question d9("Дадена е машина с побайтово адресируема основна памет и 2-кратен множествено асоциативен кеш. Кеш-логиката интерпретира адреса от паметта\nкакто следва: 14 бита за таг, 8 бита за множество, 2 бита за адресиране на дума\n.Колко е максималният брой на блоковете в главната памет (изберете едно)?");
	d9.AddOption("Не може да бъде определен", -1);
	d9.AddOption("2^2", -1);
	d9.AddOption("2^8", -1);
	d9.AddOption("2^22", 1);//veren
	d9.AddOption("2^14", -1);
	d9.AddOption("2^24", -1);
	exam.push_back(d9);

	Question d10("Кеш-памет с асоциативна организация е с капацитет 64 линии, разделени на множества с по 16 линии всяко. Основната памет съдържа 4К блока с по 128 думи всяка.\nПосочете адресният формат, който й съответства (форматът е: tag, set, word):");
	d10.AddOption("8 2 7", 1);//towa bi trqbwalo da e vqrno , but who knows, definitely not Cvetanov
	d10.AddOption("14 8 4", -1);
	d10.AddOption("14 8 7", -1);
	d10.AddOption("4 8 7", -1);
	exam.push_back(d10);

	Question d11("Методът, при който запис на данните се извършва само в кеш-паметта, а състоянието на кеш-блока се отбелязва\nкато обикновено в управляващото поле с признак, наречен \"update\" или \"dirty\" се нарича:");
	d11.AddOption("Обратен запис (Write back)", 1);
	d11.AddOption("Едновременен запис (Write through)", -1);
	exam.push_back(d11);

	Question q36("Какъв е форматът на линията при кеш-памет с асоциативна организация?");
	q36.AddOption("таг, линия, дума", -1);
	q36.AddOption("таг, дума", 1);
	q36.AddOption("таг, множество, дума", -1);
	exam.push_back(q36);

	Question q37("При кой от трите метода на разполагане блокове от операционната памет в кеша е най-малко вероятно два блока да бъдат записани на една и съща линия?");
	q37.AddOption("Пълна асоциативност", 1);
	q37.AddOption("Директно съпоставяне", -1);
	q37.AddOption("Множествена асоциативност", -1);
	exam.push_back(q37);

	Question q0("Дадена е машина с побайтово адресируема основна памет 2^24 байта и с кеш за данни с директна организация и с капацитет 64k и 32-байтови блокове. Колко бита са необходими за таг, блок и отместване?");
	q0.AddOption("8 бита за таг, 5 бита за блок, 11 бита за уникална дума", -1);
	q0.AddOption("8 бита за таг, 11 бита за блок, 5 бита за уникална дума", 1);
	q0.AddOption("11 бита за таг, 8 бита за блок, 5 бита за уникална дума", -1);
	exam.push_back(q0);

	Question q1("Кои от изброените подходи способстват за намаляване на латентността при зареждане на данни в кеша?");
	q1.AddOption("Отложен запис на данни", 0.34);
	q1.AddOption("Зареждане при поискване", 0.33);
	q1.AddOption("Обратен запис", -1);
	q1.AddOption("Едновременен запис", -1);
	q1.AddOption("Спекулативно зареждане", 0.33);
	exam.push_back(q1);

	Question q25("Кое от изброените не е вярно за кеш-паметта?");
	q25.AddOption("Намира се в адресното пространство на процесора и може да се адресира с помощта на машинните инструкции", 1);
	q25.AddOption("Осигурява бърз достъп до интензивно използваните данни чрез тяхното предварително зареждане", -1);
	q25.AddOption("Съгласува интерфейса на процесора и контролера на паметта", -1);
	exam.push_back(q25);

	Question q33("Кои от изброените алгоритми за управление на заместването на блокове при кеш-паметите се основават на оценка на вероятността за обръщение към блока в бъдеще време?");
	q33.AddOption("Алгоритъм за случайния избор RC (random choice)", -1);
	q33.AddOption("Алгоритъм FIFO", -1);
	q33.AddOption("Алгоритъм LFU (Least Frequently Used)", -1);
	q33.AddOption("Алгоритъм LRU (Least Recently Used)", -1);
	q33.AddOption("Нито един от посочените.", 1);//Algoritmite za upravlenie na zamestvaneto, koito se osnovavat na ocenka na veroqtnostta za obryshtenie na bloka v budeshte vreme se narichat fizicheski nerealiziruemi
	exam.push_back(q33);						//src http://www.tyanev.com/resources/books/ComputerOrganization/OK_632.HTM?fbclid=IwAR1HMqF44Y7Y8QsChrI4_m4pZPm4yy4BZJmsDMuHMyWh2jLShvHi7oc6mcw

	//virtual memory
	Question q11("Кой от посочените методи не е метод за преобразуване на виртуални адреси?");
	q11.AddOption("Метод на странична организация", -1);
	q11.AddOption("Метод на сегментно-странична организация", -1);
	q11.AddOption("Метод на локалността", 1);
	q11.AddOption("Метод на сегментна организация", -1);
	exam.push_back(q11);

	Question q3("Колко е максималният брой страници с размер на страниците 4k при 32-битов адрес?");
	q3.AddOption("1M", 1);
	q3.AddOption("64k", -1);
	q3.AddOption("5k", -1);
	q3.AddOption("20k", -1);
	exam.push_back(q3);

	Question q4("Какво съдържа TLB при странична организация на паметта?");
	q4.AddOption("Моментна карта на състоянието на страниците на оперативната памет", 1);
	q4.AddOption("Таблица с номера на физически страници, принадлежащи на даден процес", -1);
	q4.AddOption("Таблица с номера на виртуални страници, принадлежащи на даден процес", -1);
	q4.AddOption("Таблица на страниците на диска", -1);
	exam.push_back(q4);

	Question q5("Коя от изброените характеристики не описва таблицата на страниците?");
	q5.AddOption("Таблицата на страниците се състои от редове, всеки ред от таблицата съответства на номер на виртуална страница", -1);
	q5.AddOption("Таблицата на страниците съдържа информация за активните процеси", 1);
	q5.AddOption("Таблицата на страниците е допълнена с бит за присъствие, показващ дали съответната страница се намира в свободната памет", -1);
	q5.AddOption("Таблицата на страниците се пази някъде в оперативната памет", -1);
	exam.push_back(q5);

	Question q6("Какво е предназначението на TLB?");
	q6.AddOption("Да минимизира загубата на бързодействие при търсене на физическото разположение на данните", 1);
	q6.AddOption("Да преобразува виртуалните странични адреси във физически", -1);
	q6.AddOption("Да намали производителността на хардуерна имплементация", -1);
	exam.push_back(q6);

	Question q7("Какви типове памет се използват за съхранение и поддържане на таблиците на страниците при статична организация на паметта?");
	q7.AddOption("Кешова с директна организация", -1);
	q7.AddOption("Асоциативни кешове", 0.5);
	q7.AddOption("Множество асоциативно кешове", 0.5);
	q7.AddOption("Външна дискова памет", -1);
	q7.AddOption("Главна памет", -1);
	exam.push_back(q7);

	//addressing modes
	Question q8("Посочете за кой от изброените режими на адресация се отнася показаната фигура\n| код | операнд |");
	q8.AddOption("Индексна", -1);
	q8.AddOption("Косвена", -1);
	q8.AddOption("Вложена", -1);
	q8.AddOption("Непосредствена", 1);
	exam.push_back(q8);

	Question q9("Как се оказва стойността на операнда при регистров режим на адресация?");
	q9.AddOption("Задава се в кода на инструкцията", -1);
	q9.AddOption("Задава се чрез константно отместване спрямо началото на програмния сегмент", -1);
	q9.AddOption("Задава се с номера на регистъра", 1);
	exam.push_back(q9);

	Question q10("При кой от изброените методи на адресация в адресната част на инструкцията е записан адресен указател?");
	q10.AddOption("Индексна адресация", -1);
	q10.AddOption("Директна адресация", -1);
	q10.AddOption("Индексна адресация с регистри", -1);
	q10.AddOption("Непосредствена адресация", -1);
	q10.AddOption("Индиректна адресация", 1);
	exam.push_back(q10);

	Question q12("Къде е местоположението на операнда при регистрово косвена адресация?");
	q12.AddOption("В регистър", -1);
	q12.AddOption("В основната памет", 1);
	q12.AddOption("Във вторичната памет", -1);
	q12.AddOption("В кода на инструкцията", -1);
	exam.push_back(q12);

	Question q13("Как се указва ефективния адрес на операнда в паметта при непосредствен режим на адресация?");
	q13.AddOption("Чрез адрес на регистър на микропроцесора", -1);
	q13.AddOption("Чрез стековия указател", -1);
	q13.AddOption("Чрез адресното поле на операнда в кода на инструкцията", 1);
	exam.push_back(q13);

	Question q28("Колко е максималният брой страници с размер 8 при 8-битов адрес?");
	q28.AddOption("16", -1);
	q28.AddOption("32", 1);
	q28.AddOption("64", -1);
	q28.AddOption("512", -1);
	q28.AddOption("4k", -1);
	exam.push_back(q28);

	Question q29("При размер на страниците 8 и 8-битов адрес, кой ред на таблицата съдържа адреса на страницата?");
	q29.AddOption("3", 1);
	q29.AddOption("5", -1);
	q29.AddOption("7", -1);
	q29.AddOption("10", -1);
	q29.AddOption("12", -1);
	exam.push_back(q29);

	//pipelining
	Question u7("Посочете при конвейерната обработка на коя от дадените последователности от инструкции възниква хазарт от типа write-after-read:");
	u7.AddOption("ADD R3, R2, R1; R3 = R2 + R1", -1);
	u7.AddOption("ADD R3, R2, R1; R3=R2+R1  SUB R2, R3, 1; R2=R3-1  ADD R3, R2, R5; R3 = R2+R5", 1);
	u7.AddOption("ADD R3, R4, R5 SUB R2, R2, 1 BEQ R2, R0, L1", -1);
	exam.push_back(u7);

	Question u8("Знаейки, че ускорението е правопропорционално на броя фази на конвейера, защо реално полученото ускорение е по-малко в сравнение с теоретично достижимото?");
	u8.AddOption("Заради хазартите", 0.5);
	u8.AddOption("Заради по-високата патентност за индивидуалните инструкции", -1);
	u8.AddOption("Заради времето необходимо за запълване на конвейера", 0.5);
	exam.push_back(u8);

	Question u9("Разделянето на инструкциите на отделни фази на обработка е характерно за (изберете едно или повече):");
	u9.AddOption("разпределената обработка", -1);
	u9.AddOption("паралелната обработка", -1);
	u9.AddOption("системната обработка", -1);
	u9.AddOption("конвейерната обработка", 0.5);
	u9.AddOption("поддържането на паралелизъм на ниво инструкции", 0.5);
	exam.push_back(u9);

	Question u10("Колко машинни цикъла ще са необходими за конвейерна обработка на 1500 инструкции в 5-фазен линеен инструкционен конвейер?");
	u10.AddOption("1505", -1);
	u10.AddOption("7500", -1);
	u10.AddOption("18", -1);
	u10.AddOption("1504", 1);
	exam.push_back(u10);

	Question u11("Как се преодоляват хазартите в конвейера при достъп до общи ресурси в инструкционния поток (изберете едно или повече)?");
	u11.AddOption("чрез пренареждане на инструкционния поток от компилатора", -1);
	u11.AddOption("чрез предсказване на преходите в инструкционния поток", -1);
	u11.AddOption("чрез дублиране на критичните фази", -1);
	u11.AddOption("чрез блокиращи техники на конвейера за определено време и последователна обработка", 0.5);
	u11.AddOption("чрез прескачане на критичните фази", -1);
	u11.AddOption("чрез въвеждане на закъснения и модифициране главната таблица на заетост на конвейера", 0.5);
	exam.push_back(u11);

	Question u12("В инструкционния конвейер се изпълняват едновременно (изберете едно):");
	u12.AddOption("Празни инструкции", -1);
	u12.AddOption("Инструкции за условен и безусловен преход", -1);
	u12.AddOption("Инструкции в реални фази", 1);
	u12.AddOption("Записи на данни от регистрите към процесора", -1);
	exam.push_back(u12);

	Question u13("Кои от изброените техники се използват при разрешаването на проблеми при конвейерното изпълнение на инструкции с преход (изберете едно или повече)?");
	u13.AddOption("Дублиране на конвейерните ресурси", -1);
	u13.AddOption("Множествено предварително изпълване на инструкции", 1);
	u13.AddOption("Prediction Look-up Table", -1);
	u13.AddOption("Използване на специализирани функционални устройства за четене на операциите или запис на резултатите в паметта", -1);
	u13.AddOption("BTB buffer", -1);
	exam.push_back(u13);

	Question u14("Как се преодоляват конфликтите за памет при конвейеризираното изпълнение на инструкционния поток?");
	u14.AddOption("чрез въвеждане на закъснения и модифициране изходната таблица на заетост на конвейера", -1);
	u14.AddOption("чрез предсказване на преходите в инструкционния поток", 1);
	u14.AddOption("чрез пренареждане на инструкционния поток от компилатора", -1);
	u14.AddOption("чрез използване на специализирано функционално устройство за четене на операциите или запис на резултати в паметта", -1);
	exam.push_back(u14);

	Question u15("Посочете кои от изброените фактори са причина за понижаване на потоковата скорост при конвейерната обработка (изберете едно или повече):");
	u15.AddOption("Зависимости по данни", 0.25);
	u15.AddOption("Предсказване на прехода в информационния поток", -1);
	u15.AddOption("Темп на инициализация на конвейера", -1);
	u15.AddOption("Конфликти при достъп на общи ресурси", 0.25);
	u15.AddOption("Патентност на конвейерната обработка", -1);
	u15.AddOption("Използваемост на функционалните устройства по конвейера", -1);
	u15.AddOption("Анти-зависимости по данни", 0.25);
	u15.AddOption("Преходи в информационния поток, засягащи модифицирането на програмния брояч", 0.25);
	exam.push_back(u15);

	Question u16("На какво се дължат процедурните зависимости?");
	u16.AddOption("Единствено на инструкции за безусловен преход", -1);
	u16.AddOption("Единствено на инструкции за условен преход", -1);
	u16.AddOption("Инструкции за безусловен преход и инструкции с осъществен условен преход в инструкционния поток на програмата", 1);
	u16.AddOption("Едновременни заявки за един и същ ресурс", -1);
	exam.push_back(u16);

	Question u17("От какво се предизвикват ресурсните конфликти?");
	u17.AddOption("Недобро планиране на ресурсите на инструкционния конвейер", -1);
	u17.AddOption("Едновременни заявки за едни и същи ресурси", 1);
	u17.AddOption("От възникнали мехури в конвейера", -1);
	exam.push_back(u17);

	Question u18("Кои от изброените методи се използва за решаване на проблема с инструкционните хазарти (изберете едно или повече)?");
	u18.AddOption("Презареждане на конвейера", -1);
	u18.AddOption("Увеличаване размера на буферната памет в отделните функционални устройства", -1);
	u18.AddOption("Опростяване формата на инструкциите използвани от програмата", -1);
	u18.AddOption("Разделяне на инструкционния цикъл на допълнителни фази на обработка", -1);
	u18.AddOption("Пренареждане на инструкции от компилатора", 1);
	exam.push_back(u18);

	//random
	Question q14("Суперскаларен процесор обработва два инструкционни потока (от прости и сложни инструкции). Коя от изброените фази на разработка е обща и за двата потока?");
	q14.AddOption("Извличане", 1);
	q14.AddOption("Изпълнение", -1);
	q14.AddOption("Запис на резултата", -1);
	q14.AddOption("Декодиране", -1);
	exam.push_back(q14);

	Question q15("Какво е предназначението на механизмите за защита на паметта?");
	q15.AddOption("Да не допускат модифициране на системния софтуер от приложения", -1);
	q15.AddOption("Да ограничават достъпа до съхраняванията в системата информация", -1);
	q15.AddOption("Да откриват грешки при адресирането преди извършването на неразрешен достъп", -1);
	q15.AddOption("Да ограничават достъпа до определени сегменти или страници", 1);
	exam.push_back(q15);

	Question q16("Шината PCI в процесорната архитектура се явява мост между:");
	q16.AddOption("шина EISA и периферията", 1);
	q16.AddOption("системната шина на микропроцесора и шината EISA", -1);
	q16.AddOption("системната шина на микропроцесора и основната памет", -1);
	q16.AddOption("микропроцесора и кеш-паметта L2", -1);
	exam.push_back(q16);

	Question q17("Коя/кои от изброените шини не са част от системната шина?");
	q17.AddOption("Шина за данни", -1);
	q17.AddOption("Шина за логически сигнали", 1);
	q17.AddOption("Контролна шина", -1);
	q17.AddOption("Адресна шина", -1);
	exam.push_back(q17);

	Question q18("В режим на директен достъп до паметта, управлението на обмена се поема от:");
	q18.AddOption("Устройството за вход/изход", 1);
	q18.AddOption("Процесора", -1);
	q18.AddOption("Главната памет", -1);
	exam.push_back(q18);

	Question q26("Колко проводна може да бъде USB платината?");
	q26.AddOption("4", 0.5);
	q26.AddOption("9", 0.5);
	q26.AddOption("6", -1);
	exam.push_back(q26);

	Question q27("Коя е правилната дефиниция за термина CISC");
	q27.AddOption("Complex Instruction Set Computing", 1);
	q27.AddOption("Corect Index System Call", -1);
	q27.AddOption("Chip Ignore Call", -1);
	q27.AddOption("Central Integer Stack Index", -1);
	exam.push_back(q27);

	Question q39("Коя е правилната дефиниция за термина RISC");
	q39.AddOption("Reduced Instruction Set Computing", 1);
	q39.AddOption("Random Index System Call", -1);
	q39.AddOption("Risk Instruction Stack Call", -1);
	q39.AddOption("Real Invested Space Capacity ", -1);
	exam.push_back(q39);

	//ISA
	Question q19("В зависимост от режима на адресация времето на изпълнение на една процесорна инструкция може да варира в значителна степен. При коя от изброените подредби на адресни режими времето ще се изменя от много кратко до много дълго?");
	q19.AddOption("директна, косвена, непосредствена", -1);
	q19.AddOption("непосредствена, косвена, директна", -1);
	q19.AddOption("непосредствена, директна, косвена", 1);
	q19.AddOption("косвена, непосредствена, директна", -1);
	exam.push_back(q19);

	Question q20("Кой от изброените етапи не е част от инструкционния цикъл?");
	q20.AddOption("Пренареждане", 1);
	q20.AddOption("Извличане", -1);
	q20.AddOption("Изпълнение", -1);
	q20.AddOption("Декодиране", -1);
	exam.push_back(q20);

	Question q21("Кои процесори от изброените процесорни фамилии се характеризират с RISC-архитектура?");
	q21.AddOption("SPARC", 0.33);
	q21.AddOption("CYRIX", -1);
	q21.AddOption("ALPHA", -1);
	q21.AddOption("INTEL", -1);
	q21.AddOption("AMD", -1);
	q21.AddOption("MIPS-R4000", 0.34);
	q21.AddOption("ARM", 0.33);
	exam.push_back(q21);

	Question q22("Каква система инструкции имат различните фамилии мултипроцесорни архитектури?");
	q22.AddOption("Еднаква", -1);
	q22.AddOption("Съвпадаща отчасти", 0.5);
	q22.AddOption("Изцяло различна", 0.5);
	exam.push_back(q22);

	Question q23("Кой/кои от изброените етапи е част от инструкционния цикъл?");
	q23.AddOption("Пренареждане", -1);
	q23.AddOption("Извличане", 0.34);
	q23.AddOption("Изпълнение", 0.33);
	q23.AddOption("Декодиране", 0.33);
	exam.push_back(q23);

	Question q24("Кое от твърденията относно размера на страниците е невярно?");
	q24.AddOption("По-големият размер на страниците увеличава времето за входно-изходни операции (четене, запис на страници) по време на изпълнение на програмите", 1);
	q24.AddOption("По-големият размер води до въвеждане на излишна информация, която може да е излишна", -1);
	q24.AddOption("По-малкият размер на страницата води до намаляване на вътрешната фрагментация, която е 1/2 от последната страница", -1);
	exam.push_back(q24);

	//komp arch
	Question u1("От кои фактори зависи производителността на компютърните системи?");
	u1.AddOption("От времето за достъп до регистриране", -1);
	u1.AddOption("Архитектурата и технологията", 1);
	u1.AddOption("От тактовата честота", -1);
	exam.push_back(u1);

	Question u2("Единицата за измерване на производителността MIPS за съпоставяне на еднотипни процесорни архитектури се основава на:");
	u2.AddOption("Брой операции с операнди от виртуалната памет", -1);
	u2.AddOption("Брой операции с операнди от кеш-паметта", -1);
	u2.AddOption("Брой операции с операнди от главната памет", 1);
	u2.AddOption("Брой операции с операнди от флаш-паметта", -1);
	exam.push_back(u2);

	Question u3("Основни производители на x86 архитектурата са (изберете едно или повече):");
	u3.AddOption("IBM", 0.34);
	u3.AddOption("Hewlett-Packard", 0.33);
	u3.AddOption("Intel", 0.33);
	u3.AddOption("Sun Microsystems", -1);
	u3.AddOption("Advanced Micro Device", -1);
	exam.push_back(u3);

	Question u4("За какво служи програмният брояч (изберете едно)?");
	u4.AddOption("За указване на адреса на следващата инструкция за изпълнение", 1);
	u4.AddOption("За съхраняване на резултата от аритметичните операции изпълнявани в ALU-то", -1);
	u4.AddOption("За отчитане броя на изпълненията на дадена инструкция", -1);
	u4.AddOption("За отчитане на процента памет заеман от изпълняващата се програма", -1);
	exam.push_back(u4);

	Question u5("Коя е правилната дефиниция за термина SIMD (изберете едно)?");
	u5.AddOption("Single Instruction, Multiple Data", 1);
	u5.AddOption("Single Interrupt, Multiple Distribution", -1);
	u5.AddOption("Single Input, Multiple Distributions", -1);
	u5.AddOption("Single Integration, Multiple Dynamics", -1);
	exam.push_back(u5);

	Question u6("Кои от изброените техники служат за увеличаване степента на паралелизъм по време на изпълнение на програмата (изберете едно или повече)?");
	u6.AddOption("Нито едно от посочените", -1);
	u6.AddOption("Прогнозиране посоката на преходите", 0.25);
	u6.AddOption("Едновременно зареждане за изпълнение на няколко инструкции и динамично планиране", 0.25);
	u6.AddOption("Откриване и премахване на зависимости по данни при компилиране", 0.25);
	u6.AddOption("Реорганизация на циклите по такъв начин, че всяка итерация в получения код да се състои от инструкции, които са избрани от различни итерации на първоначалния цикъл (loop unrolling)", 0.25);
	exam.push_back(u6);

	Question q30("Кои от изброените характеризира архитектурната концепция EPIC?");
	q30.AddOption("Оползотворяване паралелизъм на ниво инструкция чрез изпращане на няколко инструкции на обикновения инструкционен поток в различни функционални устройства на конвейера", -1);
	q30.AddOption("Оползотворяване на явен паралелизъм на ниво инструкция", 0.34);
	q30.AddOption("Оползотворяване на скрития в програмния код на ниво компилатор и апаратна поддръжка", 0.33);
	q30.AddOption("Едновременно зареждане за изпълнение на няколко инструкции и динамично планиране", -1);
	q30.AddOption("Използване на широка шина за зареждане на инструкция и дълги конвейери с голяма задръжка", 0.33);
	exam.push_back(q30);

	Question q32("За коя от изброените компютърни архитектури се отнасят следните особености:\n-Дължината на инструкциите е стотици битове\n-В рамките на процесора функционират паралелно множество функционални устройства\n-Всички функционални устройства споделят огромен общ регистров файл");
	q32.AddOption("Потокова", -1);
	q32.AddOption("Суперскаларна", -1);
	q32.AddOption("VLIW", 1);
	q32.AddOption("EPIC", -1);
	exam.push_back(q32);

	Question q34("По какво се различават CISC от RISC?");
	q34.AddOption("Всички инструкции се характеризират с опростен формат", 1);
	q34.AddOption("Инструкциите преобладаващо са от тип памет-памет", -1);
	q34.AddOption("Всички инструкции се характеризират с една и съща дължина", -1);
	q34.AddOption("Сложните инструкции се синтезират от по-простите", -1);
	q34.AddOption("Операциите с паметта са само от типа \"Load\" и \"store\"", -1);
	exam.push_back(q34);

	Question q35("От какво се определя времето за изпълнение на програмата в процесора:\n1)алгоритъма 2)програмния език 3)компилатора 4)системата процесорни инструкции");
	q35.AddOption("1) и 3)", 1);//in Kosyo we trust
	q35.AddOption("3) и 4)", -1);
	q35.AddOption("1), 2), 3 и 4))", -1);
	q35.AddOption("1) и 2)", -1);
	q35.AddOption("2) и 3)", -1);
	q35.AddOption("2), 3) и 4)", -1);
	exam.push_back(q35);

	Question q38("От какъв тип е следната инструкция?\nADD 5,15,20");
	q38.AddOption("RISC", -1);
	q38.AddOption("CISC", 1);
	q38.AddOption("VLIW", -1);
	exam.push_back(q38);

	unsigned questionsCount = exam.size();
	for (unsigned i = 0; i < questionsCount; ++i)
		std::swap(exam[Randomize(exam.size())], exam[Randomize(exam.size())]);
	for (unsigned i = 0; i < exam.size(); ++i)
	{
		if (i == questionsCount)
		{
			std::cout << "Секция със сгрешени въпроси\nнатиснете някой бутон\n";
			std::cin >> useless;
			system("CLS");
		}
		std::cout << 1 + i << '/' << exam.size() << '\n';
		exam[i].AskQuestion();
		if (exam[i].AnswerQuestion() != 1 && !flag)
			exam.push_back(exam[i]);
		std::cin >> useless;
		system("CLS");
	}
	std::cout << "Congratulations for reaching the end!\nYour score is: " << counter << '/' << exam.size();
	std::cin >> useless;
	return 0;
}